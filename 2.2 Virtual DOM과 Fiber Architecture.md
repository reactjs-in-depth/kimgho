## 가상 돔(Virtual DOM)이란 무엇인가?

### 가상 DOM을 다루기에 앞서 DOM(Document Object Model)을 알아야 한다.

- DOM이란?
  - 웹페이지에 대한 인터페이스로 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정보를 담고있다.

- 웹페이지가 그려지는 과정을 살펴보자
  1. 브라우저가 사용자가 요청한 주소를 방문해 HTML파일을 다운로드한다.
  2. 브라우저의 렌더링 엔진은 HTML을 파싱해 DOM노드로 구성된 트리(DOM)를 만든다.
  3. 2번 과정에서 CSS파일을 만나면 해당 CSS파일도 다운로드한다.
  4. 브라우저의 렌더링 엔진은 이 CSS도 파싱해 CSS노드로 구성된 트리(CSSOM)를 만든다.
  5. 브라우저는 2번에서 만든 DOM 노드를 순회한다. 단, 사용자의 눈에 보이는 노드만 방문한다.
     -  display:none으로 설정된 요소는 방문하지 않는다는 말이다.
     -  이는 트리를 분석하는 과정을 조금이라도 빠르게 하기 위함이다.
  6. 5번에서 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 여기서 발견한 CSS 스타일 정보를 노드에 적용한다. 이때 DOM 노드에 CSS를 적용하는 과정은 크게 2가지로 나뉜다.
     - 레이아웃(layout,reflow) : 각 노드가 브라우저 화면의 어느 좌표에 정확히 나타나야 하는지 계산하는 과정으로 이 과정을 거치면 반드시 페인팅 과정도 거치게 된다.
     - 페인팅(painting) : 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정
    
![](https://velog.velcdn.com/images/kgh67811/post/bccedf24-1d89-4d74-b0e5-c0208e41a162/image.png)

![](https://velog.velcdn.com/images/kgh67811/post/86dca4cb-54b6-42ee-b638-3b9cf92236b1/image.png)

---

### 가상 DOM의 탄생 배경
- 특정 요소의 색상이 변경되는 경우, 페인팅만 일어나므로 빠르게 처리할 수 있다.
- 어떤 요소의 노출 여부가 변경되거나 사이즈가 변경되는 경우 레이아웃이 일어나고, 리페인팅도 같이 일어난다
  - 이는 더 많은 비용이 들고, DOM 변경이 일어나는 요소가 많은 자식 노드를 가진 경우, 하위 노드들도 같이 변경돼야 하므로 비용은 더욱 커진다.
- 특히, SPA에서 이러한 추가 렌더링 작업은 많이 일어난다
  - SPA의 경우 하나의 페이지에서 계속 요소를 바꾸기 때문이다.
- 요즘은 사용자와 인터랙션하는 페이지가 흔하기 때문에 매번 변경사항을 관리하는 것은 힘들다.

__이러한 문제를 해결하기 위해 가상 DOM이 탄생했다.__

---

### 그렇다면 가상 DOM은?
- 웹페이지가 표시해야 할 DOM을 메모리에 저장하고, 리액트가 실제 변경에 대한 준비가 완료됐을 때 실제 DOM에 반영한다.

![](https://velog.velcdn.com/images/kgh67811/post/f6652c56-2560-474e-9a13-cfb1d22ac882/image.png)
- 위 사진에서 보다시피 변화를 감지하고 해당 부분만 렌더링한다.

```javascript
ReactDOM.createRoot(document.getElementById('root')!.render(
<React.StrictMode>
  <App/>
</React.StrictMode>
)                      
```
- 이렇게 render()를 통해 리액트 요소 트리를 만들고, 이후 재렌더링될 때 새로운 요소를 반환한다.

- 하지만 이 요소 트리의 깊이가 깊어질 수록 연산에 필요한 시간은 굉장히 오래 걸린다.

- 그렇기 때문에 리액트는 휴리스틱 알고리즘을 통해 기존 O(N^3)을 O(N)으로 줄였는데, 이때 2가지 가정을 하였다.
1. 서로 다른 타입의 두 요소는 서로 다른 트리를 만든다.
2. 개발자가 key props를 통해, 여러 렌더링 사이에 어떤 자식 요소가 변경되지 않아야 할지 표시해줄 수 있다.

예를 들어,
```javascript
<div>
  <Greet/>
</div>

<p>
  <Greet/>
</p>
```
``div``의 ``Greet``와 ``p``의 ``Greet``를 비교하면 기존 ``Greet``는 사라지고, 새로 마운트가 된다.

또한,
```javascript
<div className="A" .../>
<div className="B" .../>
```
위의 경우, className만 수정한다.

이러한 과정을 __재조정(Reconciliation)__ 이라 한다.

즉, 어떤 부분을 새롭게 렌더링해야 하는지 __가상DOM과 실제DOM을 비교__ 하는 작업(알고리즘)이라 생각하면 된다.

---

##  React Fiber란?

- 리액트에서 관리하는 평범한 자바스크립트 객체다.
이런 파이버는 파이버 재조정자(Fiber Reconciler)가 관리하는데, 이는 위에서 설명한 가상 DOM과 실제 DOM을 비교하여 차이가 있는 경우, 변경된 정보를 가지고 있는 파이버를 기준으로 렌더링을 요청한다.


### Fiber의 역할
- 작업을 작은 단위로 분할하고 쪼갠 다음, 우선 순위를 매긴다.
- 이러한 작업을 일시 중지하고 나중에 다시 시작할 수 있다.
- 이전에 했던 작업을 다시 재사용하거나 필요하지 않은 경우에는 폐기할 수 있다.

그리고 가장 중요한 것은 __모든 과정이 비동기__ 로 일어난다는 것이다.
또 작업을 처리할 때 바로 처리하기도 하지만, __스케쥴링__ 도 한다.
### Fiber의 구성
- 우선 Fiber는 하나의 작업 단위로 구성되어 있다.
- 그리고 이런 작업 단위를 하나씩 처리하고 finishedWork()라는 작업으로 마무리한다.
- 이후 이 작업을 커밋해 실제DOM에 변경 사항을 만들어낸다.

이러한 단계는 2단계로 나눌 수 있다.
  - 렌더 단계에서 리액트는 사용자에게 노출되지 않는 모든 비동기 작업을 수행한다.
    - 이 단계에서 Fiber의 작업, 우선순위를 지정하거나 중지시키거나 버리는 작업이 일어난다.
  - 커밋 단계에선 실제DOM에 반영하기 위한 commitWork()가 실행되는데, 이 과정은 동기식으로 일어나고 중단될 수 없다.
  

```javascript
function FiberNode(tag,pedingProps,key,mode){
  // Instance
  this.tag = tag
  this.key = key
  this.elementType = null
  ...
```
실제 Fiber코드는 자바스크립트 객체로 이루어져있다.


Fiber와 리액트 요소가 가지는 중요한 차이점은
- 리액트의 경우 요소가 렌더링이 발생할 때마다 새롭게 생성된다.
- Fiber는 가급적 재사용된다.
  - 이는 컴포넌트가 최초로 마운트되는 시점에 생성되어 이후 가급적 재사용된다.



### Fiber Tree
- Fiber Tree는 LCRS(Left Child Right Sibling)로 구성되어 있다.
- 리액트 내부에는 Fiber Tree가 2개 존재한다.
   - 하나는 현재, 하나는 작업중인 workInProgree트리다.

Fiber 작업이 끝나면 리액트는 단순히 포인터만 변경하여 workInProgress트리를 현재로 바꾼다.
  - 이 기술을 더블 버퍼링(Double Buffering)이라 한다.
![](https://velog.velcdn.com/images/kgh67811/post/4e1f99f9-768c-4c11-8d3d-f530b2a5b4f9/image.png)

> 더블 버퍼링이란, 
그래픽 분야에서 사용하는 용어로, 화면에 표시되는 것을 그릴 때 내부적으로 처리를 하는데 이때 한 번에 모든 작업을 마무리할 수 없다.
그래서 보이지 않는 곳에서 그 다음 상황에 대한 그림을 미리 그려놓고, 완성되면 현재 상태를 새로운 그림으로 바꾼다.

이러한 더블 버퍼링은 커밋 단계에서 수행된다.


### Fiber 작업 순서

1. 리액트는 beginWork() 함수를 실행하여 Fiber 작업을 수행하는데, 더 이상 자식이 없는 Fiber를 만날 때까지 트리 형식으로 시작된다.
2. 1번에서 작업이 끝난다면 그다음 completeWork() 함수를 실행하여 Fiber 작업을 완료한다.
3. 형제 노드가 존재한다면 형제로 넘어간다.
4. 2,3번이 모두 끝났다면 return으로 돌아가 자신의 작업이 완료됐음을 알린다.

책의 예제 코드를 보면
```html
<A1>
  <B1>안녕하세요</B1>
  <B2>
    <C1>
      <D1/>
      <D2/>
    </C1>
  </B2>
  <B3/>
</A1>
```
위와 같은 구조로 있을때 자식 노드가 있다면 beginWork()를, 없다면 completeWork()를 호출하고, 형제 노드가 있다면 형제노드로 넘어가 beginWork()를 수행한 후, 다시 올라가며 completeWork()를 수행한다.
이후 Root가 완성되는 순간 최종 completeWork()를 수행하고 변경 사항을 DOM에 반영한다.

이제 최초 렌더링때 만든 Fiber를 되도록 재사용하며 기존 Fiber에서 업데이트된 props를 받아 Fiber 내부에서 처리한다.

이 과정이 위에서 말한 비동기로 이루어지며, 스케쥴링을 할 수도 있다는 것이다.
 - 과거 트리 업데이트 과정을 재귀적으로 하나의 트리를 순회하여 새 트리를 만드는 작업이 동기적이고 중단이 불가능했다.
 - 그러나 이젠 우선순위에 따라 업데이트 순서를 조정하고 업데이트를 일시 중단하거나 새롭게 만들고, 폐기할 수 있다.
 - 또한 작업 단위를 나누어 우선순위를 할당하는 것 또한 가능하다.
 
 ---
> 요약하면
Fiber는 리액트 컴포넌트에 대한 정보를 1:1로 가지고 있고, 리액트 아키텍처 내부에서 비동기로 이뤄진다.

> DOM에 반영하는 것은 동기적으로 일어나야 하고, 작업이 많은 경우 화면에 불완전한 상태로 표시될 수 있으므로 이러한 작업을 메모리에서 수행하여 최종 결과만 DOM에 적용한다.

__리액트 개발자 댄 아브라모프(dan_abramov)에 의하면 virtual DOM이라는 용어는 React가 렌더링할 때마다 DOM을 생성하지 않는다는 점을 명확히 하기 위해 도입했지만, 현재는 DOM의 이슈를 극복하기 위해 도입했다는 오해를 하고 있어 virtual DOM이라는 단어 대신 value UI라고 표현하기를 권한다고 한다.__

---
참고자료 :   
[가상DOM과 재조정](https://devowen.com/496)   
[React Fiber의 이해](https://velog.io/@huisso/TIL-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%EB%A0%8C%EB%8D%94%EB%A7%81%EC%9D%84-%EC%9C%84%ED%95%9C-React-Fiber%EC%9D%98-%EC%9D%B4%ED%95%B4)   
[React Fiber 아키텍처 분석](https://d2.naver.com/helloworld/2690975)   
[Fiber 아키텍처의 개념과 Reconciliation 이해하기](https://m.blog.naver.com/dlaxodud2388/223195103660)   
